<?xml version='1.0' encoding='UTF-8'?>
<scribes version="0.1">
    <snippet>
        <entry>
            <trigger id="python">.</trigger>
            <description>Object Reference</description>
            <template>self.${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">bcmt</trigger>
            <description>Block Comment</description>
            <template>################################################################################
#
#	${cursor}
#
################################################################################

</template>
        </entry>
        <entry>
            <trigger id="python">brk</trigger>
            <description>break statement</description>
            <template>break</template>
        </entry>
        <entry>
            <trigger id="python">class</trigger>
            <description>Class definition</description>
            <template>class ${class_name}(${object}):
	"""
	${class_documentation}
	"""
	${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">classtemp</trigger>
            <description>class template</description>
            <template>class ${ClassName}(${object}):
	"""
	${class_documentation}
	"""
	# Tracking a Classâ€™s Instances
	# Using List
	Instances = []

	# Using Dictionary:
	# Instances = {}

	# Fundamental Methods
	def __init__(self, ${arg1}, ${arg2}, ${...}):
		self.${var1} = ${arg1}
		self.${var2} = ${arg2}
		self.${ldata} = []
		self.${ddata} = {}
		# If it is derived class
		# super(${ClassName}, self).__init__(${args to base class})
		# Using List
		self.Instances.append(self)
		# Using Dictionary
		# self.Instances[self.${idfield}] = self
		# no return

	def __repr__(self):
		return ${string used by the interpreter to print instances}

	def __str__(self):
		return ${string used by print and str}

	# Predicates
	def __lt__(self, other):
		if type(self) != type(other):
			raise Exception(
				'Incompatible argument to __lt__: ' +
				str(other))
		return ${self.somemethod() &lt; other.somemethod()}

	def is_some_characteristic(self):
		return ${True or False}

	# Access Methods
	# For list
	def get_${ldata_point}(self): # returning generator  not orginal
		return (${ldata_point} for ${data_point} in self.${ldata})

				
	def add_${ldata_point}(self, ${arg}, ${...}):
		self.${ldata}.append(${arg})
		# self.${data}["key"] = []
	
	def remove_${ldata_point}(self, ${arg}):
		self.${ldata}.remove(${arg})
	
	# For dictionary
	def get_${ddata_point}(self): # returning generator  not orginal
		return (${data_point} for ${data_point} in self.${ddata}.keys())
				
	def add_${ddata_point}(self, ${key}, ${value}):
		self.${ddata}[${key}] = ${value}
	
	def remove_${ldata_point}(self, ${key}):
		del self.${ddata}[${key}]

	# Modification Methods
	def set_${something}(self, ${...}):
		# change the value of one or more fields based on
		# the parameter values supplied in the call.
		# generally no return value

	# Action Methods
	def do_something(self, ${...}):
		# do something that has effects outside the class

	# Private Support Methods
	def helper_method(self, ${...}):
		# something used by other methods of the class only
	
	# Class methods
	# To external call from class, ClassName.class_method(arg1, arg2, ..)
	# To external call from object, ClassName.class_method(arg1, arg2, ..)
	# Internal call in a class method, cls.class_method(arg1, arg2, ..)
	# Internal call in an instance method, self.class_method(arg1, arg2, ..)
	@classmethod
	def ${class_method}(cls, ${...})
		${do something}
		return ${value}
	
	@classmethod
	def InstanceCount(cls):
		return len(cls.Instances)
	
	@classmethod
	def GetInstances(self): # returning generator  not orginal
		return (value for value in self.Instances)
		# return (value for value in self.Instance.keys())
	
	@classmethod
	def Get(self, target):
	"""
	Return the instance whose GID is target
	"""
		for inst in self.GetInstances:     # using the Find template
			if target == inst.get_gid():   # define a get_gid method
			return inst
		# return self.Instances.get(target, None) </template>
        </entry>
        <entry>
            <trigger id="python">cmt</trigger>
            <description>python Comment</description>
            <template># ${comment}</template>
        </entry>
        <entry>
            <trigger id="python">cont</trigger>
            <description>continue statement</description>
            <template>continue</template>
        </entry>
        <entry>
            <trigger id="python">del</trigger>
            <description>Instance Destructor</description>
            <template>def __del__(self):
	${statement}
	from gc import collect
	collect()</template>
        </entry>
        <entry>
            <trigger id="python">dic</trigger>
            <description>Dictionary type</description>
            <template>${adic} = {'${key1}': ${value1}, '${key2}': ${value2}, '${key3}': ${value3}, ${...}}
# ${adic} = dict(${key1} = ${value1}, ${key2} = ${value2}, ${key3} = ${value3}, ${...}}</template>
        </entry>
        <entry>
            <trigger id="python">diccomp</trigger>
            <description>Dictionary comprehension</description>
            <template>adic = dict((${expression for key}, ${expression for value}) for (${key}, ${value}) in ${two-element lists or tuples})
# Py3, adic = {${expression for key}: ${expression for value} for key, value in collection}

# dict((${x}, ${x}) for ${x} in ${items})
# Py3, {${x}:${x} for ${x} in items}</template>
        </entry>
        <entry>
            <trigger id="python">edic</trigger>
            <description>Empty Dictionary</description>
            <template>${adic} = {}</template>
        </entry>
        <entry>
            <trigger id="python">elif</trigger>
            <description>An else if statement</description>
            <template>elif ${condition}:
	${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">elist</trigger>
            <description>Empty list</description>
            <template>${alst} = []</template>
        </entry>
        <entry>
            <trigger id="python">else</trigger>
            <description>An else statement</description>
            <template>else:
	${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">eq</trigger>
            <description>If Equal Statement</description>
            <template>${name} == ${value}</template>
        </entry>
        <entry>
            <trigger id="python">etup</trigger>
            <description>Empty Tuple</description>
            <template>${atup} = ()</template>
        </entry>
        <entry>
            <trigger id="python">f</trigger>
            <description>False</description>
            <template>False</template>
        </entry>
        <entry>
            <trigger id="python">fdoc</trigger>
            <description>Function documentation</description>
            <template>"""
${Enter_documentation}
"""${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">fimp</trigger>
            <description>From import statement</description>
            <template>from ${module} import ${object}</template>
        </entry>
        <entry>
            <trigger id="python">for</trigger>
            <description>python looping construct</description>
            <template>for ${item} in ${list}:
	${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">fun</trigger>
            <description>Function definition</description>
            <template>def ${function_name}(${arg1}, ${arg2} = ${value}, ${...}, ${*args}, ${**kwargs}):
	"""
	${Enter documentation here}
	"""
	# args - Collects extra positional args as a new tuple
	# for arg in args:
	# kwargs Collects extra keyword args passed as a new dictionary
	# for key in kwargs:
	${do something here}
	return ${somevalue}
	# yield ${expression}</template>
        </entry>
        <entry>
            <trigger id="python">fxm</trigger>
            <description>Fixme Comment</description>
            <template>#FIXME: ${comment}</template>
        </entry>
        <entry>
            <trigger id="python">gbl</trigger>
            <description>Global Statement</description>
            <template>global</template>
        </entry>
        <entry>
            <trigger id="python">global</trigger>
            <description>Allows globals to be created or changed within a function or class</description>
            <template>global ${GL1}, ${GL2}</template>
        </entry>
        <entry>
            <trigger id="python">hdr</trigger>
            <description>python Header</description>
            <template>#! /usr/bin/env python
# -*- coding: utf8 -*-
${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">if</trigger>
            <description>Conditional statement</description>
            <template>if ${condition}:
	${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">ifs</trigger>
            <description>If-Else conditional statement</description>
            <template>if ${condition}:
	${statement}
else:
	${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">iftest</trigger>
            <description>Module Test</description>
            <template>if __name__ == "__main__":
	${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">imp</trigger>
            <description>Import statement</description>
            <template>import ${module}</template>
        </entry>
        <entry>
            <trigger id="python">init</trigger>
            <description>python constructor</description>
            <template>def __init__(self${parameter}):
	${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">keyvalue</trigger>
            <description>A key, value pair for a dictionary</description>
            <template>${key}: ${value},${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">lambda</trigger>
            <description>Simple anonymous function using lambda</description>
            <template>lambda ${arg1}, ${arg2}, ${...} :${single expression using arguments}</template>
        </entry>
        <entry>
            <trigger id="python">lic</trigger>
            <description>GPL License</description>
            <template>
# Copyright Â© 2010 ${Abhishek Tiwari} (abhishek@abhishek-tiwari.com)
#
# This file is part of ${ProjectName}.
#
# Files included in this package ${ProjectName} are copyrighted freeware
# distributed under the terms and conditions as specified in file LICENSE.
${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">list</trigger>
            <description>Lists are mutable (changeable) arrays of object references accessed by offset.</description>
            <template>${alst} = [${item1}, ${item2}, ${item3}, ${...}]</template>
        </entry>
        <entry>
            <trigger id="python">listcomp</trigger>
            <description>List Comprehensions</description>
            <template>[${expression} 
	for ${expr1} in ${iterable1} ${if condition1}
	for ${expr2} in ${iterable2} ${if condition2} 
	${...}
]</template>
        </entry>
        <entry>
            <trigger id="python">lst</trigger>
            <description>List statement</description>
            <template>${list_name} = [${elements}]</template>
        </entry>
        <entry>
            <trigger id="python">main</trigger>
            <description>Python main function type</description>
            <template>import sys
import getopt

class Usage(Exception):
	"""
	Usage() exception class, which we catch in an except clause at the 
	end of main()
	"""
	def __init__(self, msg):
		self.msg = msg
        
def main(argv = None):
	"""
	Description of main() function, if required collect the command line
	arguments, and activate further anlysis. 
	"""
	# An optional 'argv' argument, which allows us to call it from the 
	# interactive Python prompt
	if argv is None:
		argv = sys.argv
	try:
		try:
			opts, args = getopt.getopt(argv[1:], "h", ["help"])
		except getopt.error, msg:
			raise Usage(msg)
		# Option processing
		for option, value in opts:
			if option in ("-h","--help"):
				raise Usage(__doc__)
				sys.exit(0)
			#${do something with options here}
		# Argument processing
		for argument in args:
			argument.strip()
			#${do something with arguments here}
	except Usage, err:
		print &gt;&gt;sys.stderr, err.msg
		print &gt;&gt;sys.stderr, "for help use --help"
		return 2
	

if __name__ == "__main__":
	"""
	The main program collected into function main()
	"""
	sys.exit(main())</template>
        </entry>
        <entry>
            <trigger id="python">map</trigger>
            <description>Applies function to each item of any sequence or other iterable, and returns the individual results</description>
            <template>map(${function}, ${iterable1}, ${iterable2}, ${})
# iterable objects have a method named next()</template>
        </entry>
        <entry>
            <trigger id="python">mdef</trigger>
            <description>Method Definition</description>
            <template>def ${method_name}(self${, parameters}):
	${cursor}
	return ${value}</template>
        </entry>
        <entry>
            <trigger id="python">mdoc</trigger>
            <description>Module documentation</description>
            <template>"""
${enter_documentation_string_here}

@author: Abhishek Tiwari
@organization: Abhishek Tiwari
@copyright: Copyright Â© 2010 Abhishek Tiwari
@license: Specified in LICENSE file 
@contact: abhishek@abhishek-tiwari.com
"""
${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">next</trigger>
            <description>next method</description>
            <template>next(${myobj}, None)</template>
        </entry>
        <entry>
            <trigger id="python">nn</trigger>
            <description>None Value</description>
            <template>None</template>
        </entry>
        <entry>
            <trigger id="python">param</trigger>
            <description>Function parameter documentation</description>
            <template>@param ${argument}: ${}
@type ${argument}: ${A_or_An} ${type} object.${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">paramedit</trigger>
            <description>Scribes Editor Object Documentation</description>
            <template>@param editor: Reference to the text editor.
@type editor: An Editor object.${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">paramret</trigger>
            <description>Return value documentation</description>
            <template>@return: ${}
@rtype: ${A_or_An} ${type} object.${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">paramretevent</trigger>
            <description>Documentation for Return Value for GObject Signals</description>
            <template>@return: True to propagate signals to parent widgets.
@type: A Boolean Object.${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">paramself</trigger>
            <description>Self parameter documentation</description>
            <template>@param self: Reference to the ${class} instance.
@type self: ${A_or_An} ${class} object.${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">paramt</trigger>
            <description />
            <template>@return: True to call this function again, False otherwise.
@rtype: A Boolean object.</template>
        </entry>
        <entry>
            <trigger id="python">print</trigger>
            <description>A print statement</description>
            <template>print ${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">ps</trigger>
            <description>Pass Statement</description>
            <template>pass</template>
        </entry>
        <entry>
            <trigger id="python">range</trigger>
            <description>range function</description>
            <template>range(${start}, ${stop}, ${step}) 
# start, step default to 0, 1</template>
        </entry>
        <entry>
            <trigger id="python">ret</trigger>
            <description>Return Statement</description>
            <template>return</template>
        </entry>
        <entry>
            <trigger id="python">set</trigger>
            <description>A set is an unordered collection of items that contains no duplicates</description>
            <template>${aset} = set(${any iterable such as string})</template>
        </entry>
        <entry>
            <trigger id="python">setcomp</trigger>
            <description>Set comprehensions</description>
            <template>${aset} =  set(${expression} for ${item} in ${collection})
# Py3, ${aset} =  {${expression} for ${item} in ${collection}}</template>
        </entry>
        <entry>
            <trigger id="python">setup</trigger>
            <description>setup.py basic</description>
            <template>
try:
	from setuptools import setup
except ImportError:
	from distutils.core import setup
 
config = {
	'name' : '${ProjectName}',
	'description': '${ProjectDescription}',
	'author': 'Abhishek Tiwari',
	'url': 'http://github.com/abhishektiwari/${ProjectName}',
	'download_url': 'http://github.com/abhishektiwari/${ProjectName}',
	'author_email': 'abhishek@abhishek-tiwari.com',
	'version': '0.1',
	'install_requires': ['${ModuleName1}','${ModuleName1}'],
	'packages': ['${PackageName}', '${PackageName}'],
	'scripts': [],
}

setup(**config)</template>
        </entry>
        <entry>
            <trigger id="python">sprint</trigger>
            <description>Print String Statement</description>
            <template>print "${string}"${cursor}</template>
        </entry>
        <entry>
            <trigger id="python">svdef</trigger>
            <description>Instance Variable Definition</description>
            <template>self.${name} = ${value}</template>
        </entry>
        <entry>
            <trigger id="python">t</trigger>
            <description>True</description>
            <template>True</template>
        </entry>
        <entry>
            <trigger id="python">td</trigger>
            <description>Todo Comment</description>
            <template>#TODO: ${comment}</template>
        </entry>
        <entry>
            <trigger id="python">test</trigger>
            <description>A Test Template</description>
            <template>if ${editor}:
	${comment}
elif ${editor}:
	${comment}
elif ${editor}:
	${comment}
elif ${editor}:
	${comment}
else:
	${new comment}</template>
        </entry>
        <entry>
            <trigger id="python">timeoutcmt</trigger>
            <description>Timeout Function Comment</description>
            <template>This function is called repeatedly unless its return value is False.</template>
        </entry>
        <entry>
            <trigger id="python">todic</trigger>
            <description>To dictionary</description>
            <template>${adict} = dict(zip(${iterable key sequence}, ${iterable value sequence}))</template>
        </entry>
        <entry>
            <trigger id="python">tolist</trigger>
            <description>convert a collection type into list</description>
            <template>${alst} = list(${any collection type})</template>
        </entry>
        <entry>
            <trigger id="python">totup</trigger>
            <description>To tuple</description>
            <template>${atup} = tuple(${any collection type})</template>
        </entry>
        <entry>
            <trigger id="python">try1</trigger>
            <description>Handling Exceptions</description>
            <template>try:
	${some_code_block}
except (RuntimeError, TypeError, NameError, ValueError, IOError, ${AnotherError}, ${UserDefinedError}):
	print "${something about the error}"
else:
	${do_something_if_no_exception_was raised}
finally:
	${do_something_which_must_be_executed_under_all_circumstances}</template>
        </entry>
        <entry>
            <trigger id="python">try2</trigger>
            <description>Handling Exceptions</description>
            <template>#import sys
try:
	${some_code_block}
except :
	print "${something_about_error}"
	print "Unexpected error:", sys.exc_info()[0]</template>
        </entry>
        <entry>
            <trigger id="python">try3</trigger>
            <description>Handling Exceptions</description>
            <template>#import sys
try:
	${some_code_block}
except  ${SomeError} as ${errname}:
	print "${something about the error}"
except  ${AnotherError}:
	print "${something about the error}"
except:
	print "Unexpected error:", sys.exc_info()[0]
else:
	${do_something_if_no_exception_was raised}
finally:
	${do_something_which_must_be_executed_under_all_circumstances}</template>
        </entry>
        <entry>
            <trigger id="python">try4</trigger>
            <description>Exceptions Handling</description>
            <template>#import sys
try:
	${some_code_block}
except:
	print "Unexpected error:", sys.exc_info()[0]
finally:
	${do_something_which_must_be_executed_under_all_circumstances}</template>
        </entry>
        <entry>
            <trigger id="python">tup</trigger>
            <description>Tuples are immutable arrays of object references, accessed by offset.</description>
            <template>${atup} = (${item1}, ${item2}, ${item3}, ${...})</template>
        </entry>
        <entry>
            <trigger id="python">types</trigger>
            <description>Python built in object types</description>
            <template># Pythonâ€™s built-in object types

#                                                       __________ Strings (Character is string length 1)
#                                                      |
#                          ___________ Primitive ------|
#                         |                            |__________ Numbers 
#  Core object types -----|                             __________ Sets
#                         |___________ Compound or     |
#                                      Collections or  |__________ Sequences (strings, lists, tuples, bytes, bytearray)
#                                      Containers.     |
#                                                      |__________ Mappings (dictionary)
</template>
        </entry>
        <entry>
            <trigger id="python">yield</trigger>
            <description>use only in function defintion</description>
            <template>yield ${expression}
# next(${var},None) to access the values</template>
        </entry>
    </snippet>
</scribes>
